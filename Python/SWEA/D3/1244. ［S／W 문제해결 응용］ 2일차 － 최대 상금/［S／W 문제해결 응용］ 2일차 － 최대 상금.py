# 재설계
# 1. 숫자판의 정보와 교환 횟수를 입력받는다.
# 2. 숫자판의 정보를 리스트로 변환해 각 자릿수를 쉽게 접근할 수 있게 한다.
# 3. DFS 백트래킹 방식으로 가능한 모든 교환 조합을 탐색한다.
#    - 백트래킹: 교환 후 탐색이 끝나면 원래 상태로 되돌린다.
# 4. 가지치기(pruning) 기법으로 이미 만들어 본 숫자 조합은 건너뛴다.
#    - 방문한 숫자 조합을 기록하는 집합을 만들어 중복을 방지한다.
#    - 숫자 조합을 문자열로 변환해 집합에 추가한다.
#    - 교환 횟수가 짝수일 때는 원래 상태로 돌아갈 수 있어 방문 처리를 상태와 교환 회수의 조합으로 함
#    - 같은 숫자 조합이라도 남은 교환 횟수가 다르면 다른 결과를 만들 수 있음
# 5. 교환 횟수가 0이 될 때까지 모든 가능한 교환 위치를 탐색한다.
# 6. 최대값을 갱신하며 교환 횟수가 0이 되면 탐색을 종료한다.
# 7. 최대값을 출력한다.

# 이전 코드에서 실패 가능한 반례
# 이전 코드는 방문한 숫자 조합을 기록할 때 교환 횟수를 고려하지 않았다.
# 교환 횟수가 짝수일 때는 원래 상태로 돌아갈 수 있어 방문 처리를 상태와 교환 회수의 조합으로 함
# 다르게 말하면 같은 숫자 조합이라도 남은 교환 횟수가 다르면 다른 결과를 만들 수 있음
# 예를 들어,
# 32888을 2번 교환할 때 -> 88832가 되고
# 32888을 3번 교환할 때 -> 추가 교환이 필요하지만 이전 코드는 방문했다고 판단하여 건너뜀
# 따라서 교환 횟수가 짝수일 때,
# 예: 94 -> 49 (교환 횟수 1회) -> 94 (교환 횟수 2회)
# 이렇게 교환 횟수가 짝수일 때는 원래 상태로 돌아갈 수 있어 방문 처리를 상태와 교환 회수의 조합으로 하면 같은 숫자 조합이라도 다른 교환 횟수에서는 재방문할 수 있게 되어 누락된 케이스를 처리할 수 있음

def dfs(cnt):
    global max_num
    # 지정된 교환 횟수에 도달하면 최대값 갱신
    if cnt == change:
        max_num = max(max_num, int(''.join(num)))
        return
    
    # 모든 가능한 교환 위치를 탐색
    for i in range(len(num)):
        for j in range(i+1, len(num)):
            # 숫자판 교환 
            num[i], num[j] = num[j], num[i]
            
            # 가지치기 - 방문한 숫자 조합을 기록
            current = ''.join(num)
            # 교환 횟수가 짝수일 때는 원래 상태로 돌아갈 수 있어
            # 방문 처리를 상태와 교환 회수의 조합으로 함
            key = (current, cnt)
            if key not in visited:
                visited.add(key)
                # 교환 횟수를 증가시키며 재귀 호출
                dfs(cnt+1)
                
            # 백트래킹 - 교환 전 상태로 되돌림
            num[i], num[j] = num[j], num[i]

for t in range(1, int(input())+1):
    num, change = input().split()
    num = list(num)
    change = int(change)
    visited = set()  # 이미 확인한 숫자 조합을 기록하는 집합
    max_num = 0
    dfs(0)
    print(f'#{t} {max_num}')
