# 문제가 이해 안되니 다시 정리해보자.
# N개의 지점이 있고, M개의 도로와 W개의 웜홀이 있다.
# 도로는 방향이 없으니 양방향이고 웜홀은 단방향이다.
# 도로는 시간이 양수이고 웜홀은 시간이 음수이다.
# 왜냐하면 도로는 시간이 걸리는 것이고 웜홀은 시간이 줄어드는 것이다.
# 한 지점을 출발해서 다시 출발지점으로 돌아왔을 때 출발하였을 때보다 시간이 줄어들면 YES, 아니면 NO를 출력한다.

# 입력이 잘 이해 안되니 적으면서 정리해보자.
# 벨만-포드 알고리즘을 찾아보니 음수 처리를 하기 위해 음수 사이클을 찾아서 처리한다.
# 음수 사이클이란 한 정점을 여러번 방문했을 때 거리가 줄어드는 것을 의미한다

# 예제 입력 정리
# 첫번째 줄은 테스트 케이스의 개수 T이다.
# 두번째 줄부터 T개의 테스트 케이스가 주어진다.
# 각 테스트 케이스는 N, M, W이 주어진다.
# N은 지점의 개수, M은 도로의 개수, W은 웜홀의 개수이다.
# 다음 M개의 줄에는 도로의 정보가 주어진다.
# 다음 W개의 줄에는 웜홀의 정보가 주어진다.
# 도로의 정보는 s, e, t로 주어진다.
# s에서 e로 가는데 t시간이 걸린다.
# 웜홀의 정보는 s, e, t로 주어진다.
# s에서 e로 가는데 t시간이 걸리는 것이 아니라 t시간이 줄어든다.

# 설계
# 여기서 다익스트라를 변형해서 음수처리를 해보려면(벨만-포드 알고리즘)
# 웜홀 정보를 저장할 때 t에 -t를 저장해보자.
# 음 그리고 음수 순환을 찾아야 하는데 어떨 때 음수 순환을 찾을 수 있을까?
# N번째 바퀴를 돌았을 때도 갱신이 발생하면 음수 순환을 찾았다고 할 수 있다.
# 왜냐하면 만약 음수가 없다면 N-1번째 바퀴에서 모든 정점을 갱신할 수 있기 때문이다.
# 다시 정리해서
# 왜 N번째 반복(반복문을 N번 도는 것)에서 값이 바뀌면 음수 사이클이라고 생각할까?
# - 우선, 우리가 한 번에 가장 짧은 길(최소 시간)을 찾으려고 할 때,
#   어떤 길은 최대 (정점의 개수 - 1)번 지나야 완전히 찾을 수 있다고 한다.
# - 예를 들어, 만약에 4개의 정점(장소)이 있다면, 
#   올바른 가장 짧은 길은 최대 3번의 이동으로 정해져야 한다.
#   왜냐하면 4번째 이동에서는 이미 최단 거리가 정해져 있기 때문이다.
# - 만약 4번째(즉, N번째)에도 이동하는 시간이 더 줄어들면,
#   "어디서든 계속 시간을 줄일 수 있다"는 뜻
# - 반대로, 모든 길의 시간이 양수라면,
#   정해진 이동 횟수(최대 N-1번) 이후에는 더 이상 시간이 줄어들지 않음.
# 즉, 문제에서 N번째에도 시간이 줄어든다면, 이것은 시간을 계속 되돌리는
# (즉, 음수 사이클이 존재하는) 상황이라는 뜻

import sys
input = sys.stdin.readline
print = sys.stdout.write

INF = int(1e9)

def main():
    T = int(input())
    for _ in range(T):
        N, M, W = map(int, input().split())
        edges = []
        
        for _ in range(M):
            s, e, t = map(int, input().split())
            edges.append((s, e, t))
            edges.append((e, s, t))
        
        for _ in range(W):
            s, e, t = map(int, input().split())
            edges.append((s, e, -t))
        
        # 모든 정점을 시작점으로 간주하기 위해 초기 거리를 0으로 설정
        distance = [0] * (N+1)
        negative_cycle = False
        
        # N번 반복했을 때 여전히 갱신이 발생하면 음수 사이클 존재
        for i in range(1, N+1):
            for s, e, t in edges:
                if distance[e] > distance[s] + t:
                    distance[e] = distance[s] + t
                    if i == N:
                        # 플래그 변수로 음수 사이클 존재 여부를 확인
                        negative_cycle = True
                        break
            if negative_cycle:
                break
        
        if negative_cycle:
            print("YES\n")
        else:
            print("NO\n")

if __name__ == '__main__':
    main()